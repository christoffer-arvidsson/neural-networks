#+TITLE: Hopfield Networks
#+setupfile: ~/Dropbox/org/orbit/articles/setup_file.org

* Recognizing digits
:properties:
:header-args: :session hopfield1 :exports both
:end:
Task is to store patterns of digits into a hopfield network, then try out which pattern different distorted patterns converge to.

Import libraries

#+begin_src jupyter-python
import sys
sys.path.append('src')

#+begin_src jupyter-python
from dataset import digit_dataset
from model import HopfieldNetwork, StochasticHopfieldNetwork

import numpy as np
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rc('image', cmap='gray')
#+end_src

#+RESULTS:

Plot the dataset we are working with

#+begin_src jupyter-python :file ./img/digits.png
fig, axes = plt.subplots(1, len(digit_dataset))
for i, ax in enumerate(axes):
    ax.imshow(digit_dataset[i], origin='upper')
    ax.xaxis.set_visible(False)
    ax.set_yticks([])

plt.show()
#+end_src

#+RESULTS:
[[file:./img/digits.png]]

Memorize the patterns by storing them

#+begin_src jupyter-python
N = np.size(digit_dataset[0])
model = HopfieldNetwork(N, asynchronous=True, zero_diagonal=True, seed=None)
model.store(np.reshape(digit_dataset, (-1, N)))
#+end_src

#+RESULTS:


Hard-code some example inputs, which we will morph into patterns via asynchronous update.

#+begin_src jupyter-python :file ./img/morphed_patterns.png :results output
x1 = np.array([[1, 1, -1, -1, -1, -1, -1, -1, 1, 1], [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, -1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, -1, -1, -1, -1, 1, 1, 1, -1], [-1, -1, 1, 1, 1, 1, 1, 1, 1, -1], [1, 1, -1, -1, -1, -1, -1, -1, 1, 1]])

x2 = np.array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, -1, -1, -1, -1, -1, -1, 1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, -1, -1, -1, 1, 1, -1, -1, -1, 1], [1, 1, -1, -1, -1, -1, -1, -1, 1, 1], [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])

x3 = np.array([[-1, -1, -1, -1, -1, -1, -1, -1, 1, 1], [-1, -1, -1, -1, -1, -1, -1, -1, 1, 1], [1, 1, 1, 1, 1, -1, -1, -1, 1, 1], [1, 1, 1, 1, 1, -1, -1, -1, 1, 1], [1, 1, 1, 1, 1, -1, -1, -1, 1, 1], [1, 1, 1, 1, 1, -1, -1, -1, 1, 1], [1, 1, 1, 1, 1, -1, -1, -1, 1, 1], [-1, -1, -1, -1, -1, -1, -1, -1, 1, 1], [-1, -1, -1, -1, -1, 1, 1, 1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, -1, -1, -1, -1, -1, -1, -1], [1, 1, 1, 1, 1, 1, 1, 1, -1, -1], [1, 1, 1, 1, 1, 1, 1, 1, -1, -1]])

patterns = [x1, x2, x3]

fig, axes = plt.subplots(2,3, figsize=(5,5))
morphed_patterns = np.zeros_like(patterns, dtype=int)
for i, pattern in enumerate(patterns):
    morphed_patterns[i] = model.predict(pattern.reshape(-1), 0, update_scheme='typewriter',
                                        stop_on_convergence=False).reshape(pattern.shape)

    ax1, ax2 = axes[:,i]
    ax1.imshow(pattern, origin='upper')
    ax2.imshow(morphed_patterns[i], origin='upper')
    ax1.xaxis.set_visible(False)
    ax2.xaxis.set_visible(False)
    ax1.set_yticks([])
    ax2.set_yticks([])

axes[0,0].set_ylabel('Original')
axes[1,0].set_ylabel('Converged')
plt.show()

#+end_src

#+RESULTS:
[[file:./img/morphed_patterns.png]]

Print text for handin.
#+begin_src jupyter-python
for pat in morphed_patterns:
    print(repr(pat))
#+end_src

#+RESULTS:
#+begin_example
array([[-1, -1,  1,  1,  1,  1,  1,  1, -1, -1],
       [-1, -1,  1,  1,  1,  1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1,  1,  1,  1,  1,  1,  1, -1, -1],
       [-1, -1,  1,  1,  1,  1,  1,  1, -1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1, -1, -1, -1, -1,  1,  1,  1, -1],
       [-1, -1,  1,  1,  1,  1,  1,  1,  1, -1],
       [-1, -1,  1,  1,  1,  1,  1,  1, -1, -1]])
array([[ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1],
       [ 1,  1,  1, -1, -1, -1, -1,  1,  1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1,  1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1, -1, -1, -1,  1,  1, -1, -1, -1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1,  1,  1],
       [ 1,  1,  1, -1, -1, -1, -1,  1,  1,  1],
       [ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1]])
array([[ 1,  1, -1, -1, -1, -1, -1, -1,  1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1,  1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1,  1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1,  1,  1,  1,  1, -1, -1, -1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1, -1,  1],
       [ 1,  1, -1, -1, -1, -1, -1, -1,  1,  1]])
#+end_example

* One-step error probability
:properties:
:header-args: :session hopfield2 :exports both
:end:

#+begin_src jupyter-python
import sys
sys.path.append('src')

,#+begin_src jupyter-python
from dataset import digit_dataset
from model import HopfieldNetwork, StochasticHopfieldNetwork

import numpy as np
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rc('image', cmap='gray')
mpl.rc('text', usetex=True)
#+end_src

#+RESULTS:

Generate random patterns
#+begin_src jupyter-python
N = 120
prob = 1/2
p = [12, 24, 48, 70, 100, 120]
rng = np.random.default_rng()
num_trials = 10**5

def generate_patterns(num_patterns, num_bits, prob, rng):
    """Generate binary patterns with probability."""
    return rng.choice([-1,1], (num_patterns, num_bits), replace=True, p=[prob, 1-prob])

#+end_src

#+RESULTS:

#+begin_src jupyter-python
def perform_trials(patterns, num_trials, rng, zero_diagonal=True):
    N = patterns.shape[1]
    model = HopfieldNetwork(N, asynchronous=True, zero_diagonal=zero_diagonal)
    model.store(np.reshape(patterns, (-1, N)))

    chosen_patterns = rng.choice(patterns, (num_trials,), replace=True)
    p_error = 0.0
    for pattern in chosen_patterns:
        morphed_pattern = model.predict(pattern, 1, update_scheme='random')
        if not np.all(morphed_pattern == pattern):
            p_error += 1.0

    p_error /= num_trials

    return p_error

p_error_zeroed = np.zeros_like(p, dtype=float)
for i, num_patterns in enumerate(p):
    print(f'ZERO: Running for p={num_patterns}...', end='\r')
    patterns = generate_patterns(num_patterns, N, prob, rng)
    p_error_zeroed[i] = perform_trials(patterns, num_trials, rng, zero_diagonal=True)

p_error_nonzeroed = np.zeros_like(p, dtype=float)
for i, num_patterns in enumerate(p):
    print(f'NONZERO: Running for p={num_patterns}...', end='\r')
    patterns = generate_patterns(num_patterns, N, prob, rng)
    p_error_nonzeroed[i] = perform_trials(patterns, num_trials, rng, zero_diagonal=False)

#+end_src

#+RESULTS:
: Running for p=120...

 #+begin_src jupyter-python :results table
print('Zeroed diagonal: ', repr(np.around(p_error_zeroed, 4)))
print('Nonzeroed diagonal: ', repr(np.around(p_error_nonzeroed, 4)))
 #+end_src

 #+RESULTS:
 : Zeroed diagonal:  array([0.    , 0.0068, 0.0552, 0.0978, 0.1325, 0.1646])
 : Nonzeroed diagonal:  array([0.0006, 0.0015, 0.0121, 0.0161, 0.0212, 0.0221])

#+begin_src jupyter-python
storage_capacities = np.array(p) / N
fig, ax = plt.subplots(1,1)
ax.plot(storage_capacities, p_error_zeroed, '.-', label='zeroed diagonal')
ax.plot(storage_capacities, p_error_nonzeroed, '.-', label='nonzeroed diagonal')
ax.set_xlabel(r'$\alpha = \frac{p}{N}$')
ax.set_ylabel(r'$p_{error}^{t=1}$')
plt.show()
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/01328c4720a73017188f24571f627fd1d83fa442.png]]

* Stochastic Hopfield network
:properties:
:header-args: :session hopfield2 :exports both
:end:
Notebook for estimating order parameters of a stochastic Hopfield network.

Load some libraries.
#+begin_src jupyter-python
import sys
sys.path.append('src')

#+begin_src jupyter-python
from model import StochasticHopfieldNetwork

import numpy as np
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rc('image', cmap='gray')
#+end_src

#+RESULTS:

Define helper functions to run two simulations
#+begin_src jupyter-python
def generate_patterns(num_patterns, num_bits, prob, rng):
    """Generate binary patterns with probability."""
    return rng.choice([-1,1], (num_patterns, num_bits), replace=True, p=[prob, 1-prob])

def run_simulation(num_patterns, num_bits, num_updates, num_experiments, rng):
    order_parameters = np.zeros(num_experiments, dtype=float)

    model = StochasticHopfieldNetwork(N, noise_parameter, seed=seed, asynchronous=True,
                                      zero_diagonal=False)
    for i in range(num_experiments):
        print(f'Running trial: {i}', end='\r')

        patterns = generate_patterns(p, N, 1/2, rng)
        model.store(patterns)

        _, order_parameters[i] = model.predict(patterns[0], num_updates,
                                               update_scheme='typewriter',
                                               stop_on_convergence=False)

    print('done.')
    return order_parameters
#+end_src

#+RESULTS:
Run for $p=7$

#+begin_src jupyter-python
seed = 1;
rng = np.random.default_rng(seed=seed)
noise_parameter = 2
N = 200
p = 7
num_updates = (2*10**5)
num_experiments = 100

order_parameters1 = run_simulation(p, N, num_updates, num_experiments, rng)
print(f'Average order parameter: {np.mean(order_parameters1)}')
#+end_src

#+RESULTS:
#+begin_example
done.
Average order parameter: 0.9028316683416583
#+end_example

Run for $p=45$
#+begin_src jupyter-python
p = 45
order_parameters2 = run_simulation(p, N, num_updates, num_experiments, rng)
print(f'Average order parameter: {np.mean(order_parameters2)}')
#+end_src

#+RESULTS:
#+begin_example
done.
Average order parameter: 0.15361914690426548
#+end_example
